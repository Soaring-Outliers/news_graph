RES_API = """<?xml version="1.0" encoding="UTF-8"?>
<results>
    <status>OK</status>
    <usage>By accessing AlchemyAPI or using information generated by AlchemyAPI, you are agreeing to be bound by the AlchemyAPI Terms of Use: http://www.alchemyapi.com/company/terms.html</usage>
    <url>http://www.nytimes.com/2015/04/20/world/middleeast/isis-video-purports-to-show-killing-of-ethiopian-christians.html?partner=rss&amp;emc=rss&amp;_r=0</url>
    <language>english</language>
    <text>CAIRO &#x2014; The Islamic State released a video on Sunday that appears to show fighters from its branches in southern and eastern Libya executing dozens of Ethiopian Christians, some by beheading and others by shooting.
Prefaced by extensive speeches and interviews that appear to take place in the Islamic State&#x2019;s strongholds in Syria and Iraq, the footage of the killings, if confirmed, would be the first evidence that the group&#x2019;s leaders in those countries are coordinating with fighters under the group&#x2019;s banner in those parts of Libya, compounding fears of its expansion across the Mediterranean.
The Islamic State, also known as ISIS or ISIL, released a video in February that appeared to show masked fighters in its western Libyan branch, the so-called Tripolitanian province of the Islamic State, beheading a group of Egyptian Christians who had been abducted in the city of Surt. The group has now established control of Surt, and its fighters there are sporadically battling militia troops from the nearby city of Misurata.
The video released on Sunday appears to show Islamic State fighters in its &#x201C;Fezzan province,&#x201D; in the south, and its &#x201C;Barqa province,&#x201D; in the east, carrying out executions according to the group&#x2019;s trademark rituals.
Militants in Egypt, Algeria, Afghanistan, Nigeria and elsewhere have all pledged loyalty to the Islamic State and its self-declared caliphate, but Libya is the first country outside the group&#x2019;s territory in Syria and Iraq where its core leadership has demonstrated practical communication and collaboration with its far-flung &#x201C;provinces.&#x201D;
If more confirmation of its authenticity emerges, the new video will upend both Western and Libyan views of the Islamic State&#x2019;s presence in the country. Fighters in the three regions of Libya had previously claimed responsibility for various acts of violence carried out in the Islamic State&#x2019;s name, but most analysts presumed that most of those fighters, at least the ones outside of Surt, were operating independently and using the name to capitalize on the group&#x2019;s fearsome reputation.
Now, fighters in all three provinces appear connected enough to the core group&#x2019;s leadership that they were able coordinate separate, mass executions, film them and send the footage back to Syria or Iraq for production and release.
During the last five minutes of the half-hour video, the footage cuts back and forth between scenes in the southern desert and a beach along the coast, at one point displaying both with a split screen. Both settings were filmed with the same sophisticated camera angles and editing that has distinguished other Islamic State films from indigenous Libyan videos.
Masked fighters lead a row of bound captives dressed in black into the desert and then shoot each of the prisoners in the back of the head. Another group of masked fighters leads a row of prisoners in orange jumpsuits along a beach and then beheads each of them with a long knife, placing the severed heads on the bodies lying on the sand as bloody surf washes over them.
&#x201C;You will not have safety even in your dreams, until you accept Islam,&#x201D; declares a masked figure, speaking English with an American accent and pointing a revolver toward the camera. &#x201C;To the nation of the cross: We are back again.&#x201D;
Of all the places the militants have used the group&#x2019;s name, Libya may also be uniquely vulnerable to penetration because of the collapse of any central authority since the overthrow of Col. Muammar el-Qaddafi four years ago.
Over the last nine months, its feuding militias and city-states have split into two main warring factions &#x2014; one controls the capital, Tripoli, and the other including the internationally recognized government has fled to the eastern cities of Tobruk and Bayda. Both factions have so far appeared more concerned with fighting each other than uniting to stop the Islamic State&#x2019;s expansion.
What&#x2019;s more, Libyan banks and homes still hold significant wealth. Vast oil deposits wait below ground, and the country&#x2019;s long Mediterranean coast is a useful departure point to destinations in Europe or around the region.
According to news reports, a spokesman for the Ethiopian government said Sunday that it could not yet confirm that those killed in the video were its citizens. Many African migrants come to oil-rich Libya seeking employment or passage to Europe.
Some of the Egyptian Christians killed by the Islamic State in western Libya were recognized in the earlier video by their families in Egypt as relatives who had been abducted in Surt, helping confirming that video&#x2019;s authenticity. Those killings prompted a retaliatory air raid by Egypt on targets in Derna, Libya, an Islamist stronghold where the Islamic State&#x2019;s &#x201C;Barqa Province&#x201D; is believed to be based.
Both the February video and the one on Sunday were released by the Al Furqan media group, which is controlled by the Islamic State&#x2019;s leadership and often distributes its propaganda. The video released on Sunday begins with about 25 minutes of scenes that appeared to have been filmed in Syria and Iraq. After reviewing the portrait of Jesus in the Quran, a narrator briefly walks through the history of the emergence of the Catholic, Eastern Orthodox and Protestantbranches of Christianity.
The video intersperses what appear to be scenes from a costume drama depicting rows of medieval Muslim soldiers marching with spears, fighting with bows and arrows, and assaulting a castle. Then it cuts briefly to footage of the Islamic State&#x2019;s leader, Abu Bakr al-Baghdadi, climbing the steps to the minbar, or pulpit, of the Mosul mosque where he proclaimed himself caliph.
A narrator, identified as Sheikh Abu Malik Anas al Nashwan, says in formal Arabic that the Islamic State requires Christians living under its dominion to convert to Islam or pay jizya &#x2014; the tax levied on non-Muslims living under Muslim rule in the Middle Ages. He speaks against a backdrop of lush foliage that looks more like northern Syria than anywhere in Libya, and the video shows a building and van used by the Islamic State to handle such payments in a town in the Syrian province of Aleppo.
The narrator repeatedly uses a derogatory term for Christians that is something like calling them Nazarenes. Yet much of the video is devoted to testimonials from people speaking Arabic with Syrian or perhaps Iraqi accents who say they are Christians living happily under the Islamic State in Aleppo, Raqqa and elsewhere. All say that they live freely after paying the tax; it is impossible to know how much coercion they may have felt at the time.
At one point, the video includes a scene of what appear to be two Islamic State fighters lecturing a schoolroom full of adult Christians on the virtues of Islam. A rifle leans against the wall behind them.
For those who refuse to convert or pay the tax, the narrator promises death and destruction, and scenes of Islamic State fighters desecrating the churches of Mosul, Iraq, illustrate the threat. &#x201C;The Christians in Mosul have chosen their own destiny,&#x201D; the narrator warns.
The video then moves to what the narrator describes as areas of Libya under the Islamic State&#x2019;s rule. A short scene depicts what appear to be African migrants converting to Islam. They are then hugged by Islamic State fighters.
After that, the video cuts to the far longer processional scenes depicting rows of African migrants escorted through the desert and along the beach. For those who refuse Islam or jizya, the narrator says, &#x201C;we owe nothing except the edge of the sword.&#x201D;
</text>
    <concepts>
        <concept>
            <text>Egypt</text>
            <relevance>0.95995</relevance>
            <dbpedia>http://dbpedia.org/resource/Egypt</dbpedia>
            <ciaFactbook>http://www4.wiwiss.fu-berlin.de/factbook/resource/Egypt</ciaFactbook>
            <freebase>http://rdf.freebase.com/ns/m.02k54</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rvViTg5wpEbGdrcN5Y29ycA</opencyc>
            <yago>http://yago-knowledge.org/resource/Egypt</yago>
        </concept>
        <concept>
            <text>Islam</text>
            <relevance>0.906098</relevance>
            <dbpedia>http://dbpedia.org/resource/Islam</dbpedia>
            <freebase>http://rdf.freebase.com/ns/m.0flw86</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rvVjLJZwpEbGdrcN5Y29ycA</opencyc>
        </concept>
        <concept>
            <text>Arabic language</text>
            <relevance>0.853767</relevance>
            <dbpedia>http://dbpedia.org/resource/Arabic_language</dbpedia>
            <freebase>http://rdf.freebase.com/ns/m.0jzc</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rvViHMJwpEbGdrcN5Y29ycA</opencyc>
            <yago>http://yago-knowledge.org/resource/Arabic_language</yago>
        </concept>
        <concept>
            <text>Syria</text>
            <relevance>0.688198</relevance>
            <website>http://www.mshtawy.com</website>
            <dbpedia>http://dbpedia.org/resource/Syria</dbpedia>
            <ciaFactbook>http://www4.wiwiss.fu-berlin.de/factbook/resource/Syria</ciaFactbook>
            <freebase>http://rdf.freebase.com/ns/m.06vbd</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rvVj7c5wpEbGdrcN5Y29ycA</opencyc>
            <yago>http://yago-knowledge.org/resource/Syria</yago>
        </concept>
        <concept>
            <text>Israel</text>
            <relevance>0.624983</relevance>
            <geo>31.0 35.0</geo>
            <website>http://www.knesset.gov.il/</website>
            <dbpedia>http://dbpedia.org/resource/Israel</dbpedia>
            <ciaFactbook>http://www4.wiwiss.fu-berlin.de/factbook/resource/Israel</ciaFactbook>
            <freebase>http://rdf.freebase.com/ns/m.062yqq</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rvViP55wpEbGdrcN5Y29ycA</opencyc>
            <yago>http://yago-knowledge.org/resource/Israel</yago>
        </concept>
        <concept>
            <text>Caliphate</text>
            <relevance>0.611671</relevance>
            <dbpedia>http://dbpedia.org/resource/Caliphate</dbpedia>
            <freebase>http://rdf.freebase.com/ns/m.026pgxk</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rfXyMUrgqEdmAAAACs0x8nw</opencyc>
        </concept>
        <concept>
            <text>Ottoman Empire</text>
            <relevance>0.611542</relevance>
            <dbpedia>http://dbpedia.org/resource/Ottoman_Empire</dbpedia>
            <freebase>http://rdf.freebase.com/ns/m.05kyr</freebase>
            <yago>http://yago-knowledge.org/resource/Ottoman_Empire</yago>
        </concept>
        <concept>
            <text>Libya</text>
            <relevance>0.57948</relevance>
            <geo>27.4 17.6</geo>
            <dbpedia>http://dbpedia.org/resource/Libya</dbpedia>
            <ciaFactbook>http://www4.wiwiss.fu-berlin.de/factbook/resource/Libya</ciaFactbook>
            <freebase>http://rdf.freebase.com/ns/m.04gqr</freebase>
            <opencyc>http://sw.opencyc.org/concept/Mx4rvViCzpwpEbGdrcN5Y29ycA</opencyc>
            <yago>http://yago-knowledge.org/resource/Libya</yago>
        </concept>
    </concepts>
</results>"""

from django.db import models
import os
import urllib
from urllib import request
import xml.etree.ElementTree as ET
import email.utils, datetime
from django.core import serializers

from progress.bar import Bar

def display_xml(xml_tree):
    nodes = [(0,xml_tree)]
    while len(nodes) > 0:
        depth, node = nodes.pop()
        s = ""
        for i in range(depth):
            s += "  "
        if node.text:
            t = node.text
            if len(t) > 80:
                print(s, node.tag, ' :: ', t[:80], "...")
            else:
                print(s, node.tag, ' :: ', t)
        else:
            print(s, node.tag)
            
        for child in reversed(list(node)):
            nodes.append((depth+1, child))

class Website(models.Model):
    name = models.CharField(max_length=255)
    url = models.URLField(max_length=255)
    rss_url = models.URLField(max_length=255)
    
    def __str__(self):
        return self.name.encode('utf-8')
        
    def json_attributes(self): # Website is the type_node
        return {
            "id": self.id,
            "node_ids": list(self.article_set.values_list('id', flat=True).distinct()),
            #"color": "#FFFFFF",
        }
    
    # Download the rss xml of a website, and extract url of articles from it,
    #   then create object Article if not already present in DB
    def download_rss_articles(self):
        # c <- get rss_url
        with request.urlopen(self.rss_url) as f:
            c = f.read().decode('utf-8')
        # Parse xml @TODO : use cElementTree in place of ElementTree (just pip install change import)
        rss = ET.fromstring(c)
        
        ### Display obtained rss ###
        if False:
            display_xml(rss)
        
        # Get all articles links, resolve them and put them into links
        # It last long, so we display a cute advancement bar
        
        links = []
        item_nodes = rss.findall('channel/item')
        n = len(item_nodes)
        bar = Bar('Creating Articles from '+self.name+' RSS', max=n)
        # For each item, we fetch or create an Article object
        if True:
            for item_node in item_nodes:
                link = item_node.find('link').text
                try:
                    # Try get from DB
                    a = Article.objects.get(rss_url=link)
                except Article.DoesNotExist:
                    # Not in DB, so we resolve the url because a lot of rss feeds give custom url redirecting to true articles
                    # Cookies must be handled because else they redirect you into an infinite loop
                    with request.build_opener(request.HTTPCookieProcessor).open(link) as f:
                        title = item_node.find('title').text
                        desc = item_node.find('description').text
                        pubDate = item_node.find('pubDate').text
                        if pubDate:
                            # rfc822 -> datetime
                            # http://stackoverflow.com/questions/1568856/how-do-i-convert-rfc822-to-a-python-datetime-object
                            pubDate = datetime.datetime.utcfromtimestamp(email.utils.mktime_tz(email.utils.parsedate_tz(pubDate)))
                        try:
                            a = Article(title=title, description=desc, url=f.geturl(), rss_url=link, website=self, date=pubDate)
                            a.fill_alchemy()
                            a.save()
                        except Exception as e:
                            print("Error:",e)
                            a = None
                if a:
                    links.append(a)
                bar.next()
        print()
        
        return links
        


class Article(models.Model):
    website = models.ForeignKey(Website)
    rss_url = models.URLField(max_length=511)
    url = models.URLField(max_length=511)
    title = models.CharField(max_length=511)
    description = models.TextField(null=True, blank=True)
    date = models.DateTimeField(null=True, blank=True)
    content = models.TextField(null=True, blank=True)
    
    entities_xml = models.TextField(null=True, blank=True)
    concepts_xml = models.TextField(null=True, blank=True)
    concepts = models.ManyToManyField('Concept', through='ArticleConcept')
    
    def __str__(self):
        return self.title
        
    def json_attributes(self): # Article is a form of Node, with Concept
        return {
            "id": self.id,
            "name": str(self),
            "importance": 1,
            "depth": 0,
            "display_name": False,
        }
    
    def call_api(self, endpoint, options = {}):
        data = {
            'apikey' : os.environ.get('ALCHEMY_API'),
            'url' : self.url,
            'outputMode' : "xml",
            'showSourceText' : 1,
        }
        data.update(options)
        url = endpoint + "?" + urllib.parse.urlencode(data)
        #with request.urlopen(url) as f:
        #    c = f.read().decode('utf-8')
        c = RES_API
        return c
    
    # Make queries to AlchemyAPI to complete Article model
    def fill_alchemy(self):
        if self.url:
            # For later, if we decide to use entities
            """
            if not self.entities_xml:
                c = self.call_api('http://access.alchemyapi.com/calls/url/URLGetRankedEntities')
                self.entities_xml = c
                self.save()
            # Parse entities...
            entities = ET.fromstring(self.entities_xml)
        
            ### Display obtained rss ###
            if True:
                display_xml(entities)
            entity_nodes = entities.findall('entities/entity')
            n = len(entity_nodes)
            #bar = Bar('Creating Entities from Article '+self.title+'', max=n)
            # For each entity, we fetch or create an Entity object
            for entity_node in entity_nodes:
                text = entity_node.find('text').text
                typ = entity_node.find('type').text
                count = int(entity_node.find('count').text)
                relevance = float(entity_node.find('relevance').text)
                print(text, typ, count, relevance)
            """
            
            if not self.concepts_xml:
                c = self.call_api('http://access.alchemyapi.com/calls/url/URLGetRankedConcepts')
                self.concepts_xml = c
            # Parse entities...
            concepts = ET.fromstring(self.concepts_xml)
        
            ### Display obtained rss ###
            if False:
                display_xml(concepts)
                
            self.content = concepts.find('text').text
            self.save()
            
            print("Langage detected:", concepts.find('language').text)
            if concepts.find('status').text == "OK":
                concept_nodes = concepts.findall('concepts/concept')
                n = len(concept_nodes)
                # For each entity, we fetch or create an Entity object
                for node in concept_nodes:
                    text = node.find('text').text
                    relevance = float(node.find('relevance').text)
                    # Fetch or create the Concept of name "text"
                    try:
                        c = Concept.objects.get(name = text)
                    except Concept.DoesNotExist:
                        c = Concept(name = text)
                        c.save()
                    # Make the link between Article and Concept (with relevance)
                    ac = ArticleConcept(article = self, concept = c, relevance = relevance)
                    ac.save()
        else:
            print("Error: url is required.")


class Concept(models.Model):
    articles = models.ManyToManyField(Article, through='ArticleConcept')
    name = models.CharField(max_length=255)
    
    def __str__(self):
        return self.name
        
    def json_attributes(self): # Article is a form of Node, with Concept
        return {
            "id": -self.id,
            "name": str(self),
            "importance": 1,
            "depth": 0,
            "display_name": True,
        }

class ArticleConcept(models.Model):
    article = models.ForeignKey(Article)
    concept = models.ForeignKey(Concept)
    relevance = models.FloatField()
    
    def __str__(self):
        return str(self.article) + " <-"+str(self.relevance)+"-> " + str(self.concept)
        
    def json_attributes(self): # Article is a form of Node, with Concept
        return {
            "id": self.id,
            "name": str(self),
            "node_from_id": self.article_id,
            "node_to_id": -self.concept_id,
            "strengh": self.relevance,
        }